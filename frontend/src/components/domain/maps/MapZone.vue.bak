<template>
  <div
    :style="zoneStyle"
    :class="zoneColor"
    @mouseenter="showTooltip()"
    @mouseleave="hideTooltip()"
    @click="forceTooltipToggle()"
  ></div>
  <div v-if="tooltipVisible" :style="tooltipStyle">
    <v-sheet class="ma-0 elevation-3 rounded px-1 pt-2" color="primary">
      <task-link v-if="relatedTask" :task="relatedTask" show-wiki-link />
      <task-objective
        v-if="props.mark.id"
        :objective="objectives.find((obj) => obj.id === props.mark.id)!"
      />
    </v-sheet>
  </div>
</template>
<script setup lang="ts">
  import { computed, defineAsyncComponent, ref } from 'vue';
  import type { CSSProperties } from 'vue';
  import type { TaskObjective, Task } from '@/types/models/tarkov';
  import { useTarkovData } from '@/composables/tarkovdata';
  const TaskObjective = defineAsyncComponent(
    () => import('@/components/domain/tasks/TaskObjective.vue')
  );
  const TaskLink = defineAsyncComponent(() => import('@/components/domain/tasks/TaskLink.vue'));
  const { objectives, tasks } = useTarkovData();
  interface Mark {
    id?: string;
    users: string[];
    floor?: string;
  }

  interface ZoneLocation {
    outline: Array<{ x: number; z: number }>;
  }

  interface MapData {
    svg?:
      | string
      | {
          bounds: number[][];
          coordinateRotation: number;
          file?: string;
          floors?: string[];
          defaultFloor?: string;
          transform?: number[];
          heightRange?: number[];
        };
  }

  const props = defineProps<{
    mark: Mark;
    zoneLocation: ZoneLocation;
    selectedFloor?: string;
    map: MapData;
  }>();
  const forceTooltip = ref(false);
  const hoverTooltip = ref(false);
  const forceTooltipToggle = () => {
    forceTooltip.value = !forceTooltip.value;
  };
  const showTooltip = () => {
    hoverTooltip.value = true;
  };
  const hideTooltip = () => {
    hoverTooltip.value = false;
  };
  const tooltipVisible = computed(() => {
    //if (props.mark.floor !== props.selectedFloor) return false;
    return forceTooltip.value || hoverTooltip.value;
  });
  const relatedObjective = computed(() => {
    return objectives.value.find((obj: TaskObjective) => obj.id === props.mark.id);
  });
  const relatedTask = computed(() => {
    return tasks.value.find((task: Task) => task.id === relatedObjective.value?.taskId);
  });
  const zoneColor = computed(() => {
    if (tooltipVisible.value) return 'text-green';
    return (props.mark as any).users.includes('self') ? 'text-red' : 'text-orange';
  });
  const relativeLocation = computed(() => {
    // Determine the leftmost x position in the array of zone positions
    // Take the bounds of the map and figure out the initial relative position
    if (!props.map.svg || typeof props.map.svg === 'string') {
      return {
        leftPercent: 0,
        topPercent: 0,
        rightPercent: 0,
        bottomPercent: 0,
        internalPercents: [],
      };
    }
    const mapLeft = props.map.svg.bounds[0][0];
    const mapTop = props.map.svg.bounds[0][1];
    const mapWidth =
      Math.max(props.map.svg.bounds[0][0], props.map.svg.bounds[1][0]) -
      Math.min(props.map.svg.bounds[0][0], props.map.svg.bounds[1][0]);
    const mapHeight =
      Math.max(props.map.svg.bounds[0][1], props.map.svg.bounds[1][1]) -
      Math.min(props.map.svg.bounds[0][1], props.map.svg.bounds[1][1]);
    // Apply coordinate rotation to the outline points
    const coordinateRotation = props.map.svg.coordinateRotation ?? 0;
    const outlinePercents: Array<{ leftPercent: number; topPercent: number }> = [];
    props.zoneLocation.outline.forEach((outline) => {
      // Get original coordinates
      const originalX = outline.x;
      const originalZ = outline.z;
      // Apply coordinate rotation if specified
      let x = originalX;
      let z = originalZ;
      if (coordinateRotation === 90) {
        // Rotate 90 degrees: (x, z) -> (-z, x)
        x = -originalZ;
        z = originalX;
      } else if (coordinateRotation === 180) {
        // Rotate 180 degrees: (x, z) -> (-x, -z)
        x = -originalX;
        z = -originalZ;
      } else if (coordinateRotation === 270) {
        // Rotate 270 degrees: (x, z) -> (z, -x)
        x = originalZ;
        z = -originalX;
      }
      // Calculate relative values using the coordinate system of the map
      const relativeLeft = Math.abs(x - mapLeft);
      const relativeTop = Math.abs(z - mapTop);
      // Calculate relative values relative to the map container
      const relativeLeftPercent = (relativeLeft / mapWidth) * 100;
      const relativeTopPercent = (relativeTop / mapHeight) * 100;
      outlinePercents.push({
        leftPercent: relativeLeftPercent,
        topPercent: relativeTopPercent,
      });
    });
    // Find the bounds of the outline
    const leftPercent = outlinePercents.reduce((min, current) => {
      return current.leftPercent < min ? current.leftPercent : min;
    }, outlinePercents[0].leftPercent);
    const topPercent = outlinePercents.reduce((min, current) => {
      return current.topPercent < min ? current.topPercent : min;
    }, outlinePercents[0].topPercent);
    const rightPercent = outlinePercents.reduce((max, current) => {
      return current.leftPercent > max ? current.leftPercent : max;
    }, outlinePercents[0].leftPercent);
    const bottomPercent = outlinePercents.reduce((max, current) => {
      return current.topPercent > max ? current.topPercent : max;
    }, outlinePercents[0].topPercent);
    // Now, calculate the percentages internally to the div based on the bounds
    const internalPercents: Array<{ leftPercent: number; topPercent: number }> = [];
    outlinePercents.forEach((outline) => {
      const internalLeftPercent =
        ((outline.leftPercent - leftPercent) / (rightPercent - leftPercent)) * 100;
      const internalTopPercent =
        ((outline.topPercent - topPercent) / (bottomPercent - topPercent)) * 100;
      internalPercents.push({
        leftPercent: internalLeftPercent,
        topPercent: internalTopPercent,
      });
    });
    return {
      leftPercent,
      topPercent,
      rightPercent,
      bottomPercent,
      internalPercents,
    };
  });

  const zoneStyle = computed(
    (): CSSProperties => ({
      position: 'absolute' as const,
      top: relativeLocation.value.topPercent + '%',
      left: relativeLocation.value.leftPercent + '%',
      width: relativeLocation.value.rightPercent - relativeLocation.value.leftPercent + '%',
      height: relativeLocation.value.bottomPercent - relativeLocation.value.topPercent + '%',
      clipPath:
        'polygon(' +
        relativeLocation.value.internalPercents
          .map((point) => {
            return point.leftPercent + '% ' + point.topPercent + '%';
          })
          .join(', ') +
        ')',
      background: tooltipVisible.value
        ? 'linear-gradient(90deg, rgba(155, 165, 0, 0.5) 0%, rgba(155, 165, 0, 0.5) 100%)'
        : 'linear-gradient(90deg, rgba(255, 165, 0, 0.2) 0%, rgba(255, 165, 0, 0.2) 100%)',
      borderStyle: 'dashed' as const,
      // cursor: props.mark.floor === props.selectedFloor ? "pointer" : "inherit",
      // opacity: props.mark.floor === props.selectedFloor ? 1 : 0.2,
      cursor: 'pointer' as const,
      opacity: 1,
    })
  );
  const tooltipStyle = computed(
    (): CSSProperties => ({
      position: 'absolute' as const,
      top: relativeLocation.value.topPercent + '%',
      left: relativeLocation.value.leftPercent + '%',
      transform: 'translate(-50%, -125%)',
      zIndex: 100,
    })
  );
</script>
<style lang="scss">
  .objective-gps-tooltip {
    width: 100%;
  }
</style>
