# This file was auto-generated by the Firebase CLI
# https://github.com/firebase/firebase-tools
# YAML schema reference: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions

# Security Architecture - Two-Workflow Pattern
# ===========================================
# This workflow implements CodeQL security recommendations for handling untrusted pull requests.
# 
# WORKFLOW 1 (Unprivileged): firebase-hosting-pr-untrusted.yml
#   - Triggered by: pull_request
#   - Context: Unprivileged (no secrets)
#   - Purpose: Safely build and test untrusted PR code
#   - Output: Upload build artifacts and metadata
#
# WORKFLOW 2 (Privileged): This file
#   - Triggered by: workflow_run (after untrusted workflow completes)
#   - Context: Privileged (access to secrets)
#   - Purpose: Trust verification and Firebase deployment
#   - Security: Only processes artifacts from trusted untrusted workflow
#
# Security Benefits:
# - Untrusted code never executes in privileged context
# - Trust verification happens after build completion
# - Artifacts are validated before deployment
# - Defense in depth with multiple security checks

name: Deploy to Firebase Hosting on PR (Privileged)
on:
  workflow_run:
    workflows: ["Firebase Hosting PR - Untrusted Code Handling"]
    types:
      - completed
    branches: [main]

permissions:
  checks: write
  contents: read
  pull-requests: write
  actions: read

jobs:
  deploy_preview:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    # Security: This only runs after the untrusted workflow completes successfully
    
    steps:
      - name: Download build artifacts (from untrusted context)
        uses: actions/download-artifact@v4
        with:
          name: pr-build-${{ github.event.workflow_run.pull_requests[0].number }}
          path: ./build-artifacts/
        # Note: These artifacts are treated as potentially malicious

      - name: Download deployment metadata (from untrusted context)
        uses: actions/download-artifact@v4
        with:
          name: pr-metadata-${{ github.event.workflow_run.pull_requests[0].number }}
          path: ./deployment-metadata/
        # Note: Metadata is validated before use

      - name: Validate PR metadata (privileged)
        id: validate_pr
        run: |
          # Security: Validate metadata from untrusted context
          if [ ! -f "./deployment-metadata/pr_number.txt" ]; then
            echo "::error::Missing PR number metadata"
            exit 1
          fi

          PR_NUMBER=$(cat ./deployment-metadata/pr_number.txt)
          PR_SHA=$(cat ./deployment-metadata/pr_sha.txt)
          PR_REPO=$(cat ./deployment-metadata/pr_repo.txt)
          PR_REF=$(cat ./deployment-metadata/pr_ref.txt)

          # Validate that PR number is numeric (prevent injection)
          if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "::error::Invalid PR number format"
            exit 1
          fi

          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "PR_SHA=$PR_SHA" >> $GITHUB_OUTPUT
          echo "PR_REPO=$PR_REPO" >> $GITHUB_OUTPUT
          echo "PR_REF=$PR_REF" >> $GITHUB_OUTPUT
          echo "✓ PR metadata validation passed"

      - name: Guard - Verify PR is trusted (privileged)
        id: guard
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = '${{ steps.validate_pr.outputs.PR_NUMBER }}';
            const pr_sha = '${{ steps.validate_pr.outputs.PR_SHA }}';
            const pr_repo = '${{ steps.validate_pr.outputs.PR_REPO }}';
            const base_repo = context.repo;

            try {
              // Get PR details
              const pr_response = await github.rest.pulls.get({
                owner: base_repo.owner,
                repo: base_repo.repo,
                pull_number: parseInt(pr_number)
              });
              
              const pr = pr_response.data;
              const repoFull = `${base_repo.owner}/${base_repo.repo}`;

              // If PR head repo is same as base repo -> trusted
              if (pr.head.repo.full_name === repoFull) {
                core.info('✓ PR from same repository - trusted');
                core.setOutput('trusted', 'true');
                return;
              }

              // Check if PR has the approved-for-preview label
              const hasApprovedLabel = pr.labels.some(label => label.name === 'approved-for-preview');
              if (hasApprovedLabel) {
                core.info('✓ PR has approved-for-preview label - trusted');
                core.setOutput('trusted', 'true');
                return;
              }

              // Otherwise, check if PR author is a collaborator
              await github.rest.repos.checkCollaborator({
                owner: base_repo.owner,
                repo: base_repo.repo,
                username: pr.user.login
              });
              core.info(`✓ PR author @${pr.user.login} is a collaborator - trusted`);
              core.setOutput('trusted', 'true');
              
            } catch (err) {
              core.warning(`✗ PR validation failed or author is not trusted: ${err.message}`);
              core.warning('Skipping preview deployment to protect secrets. Add approved-for-preview label or add user as collaborator to enable previews.');
              core.setOutput('trusted', 'false');
            }

      - name: Abort if untrusted (privileged)
        if: steps.guard.outputs.trusted != 'true'
        run: |
          echo "::notice::Untrusted PR detected in privileged workflow - deployment skipped for security"
          echo "To enable preview: Add 'approved-for-preview' label or add author as a repository collaborator"
          # Clean up artifacts to prevent resource usage
          rm -rf ./build-artifacts ./deployment-metadata
          exit 0

      - name: Validate build artifacts integrity (privileged)
        if: steps.guard.outputs.trusted == 'true'
        run: |
          # Security: Verify build artifacts before deployment
          if [ ! -d "./build-artifacts/frontend/dist" ] || [ ! -d "./build-artifacts/functions/lib" ]; then
            echo "::error::Build artifacts are missing or incomplete"
            exit 1
          fi
          echo "✓ Build artifacts integrity verified"

      - name: Copy verified artifacts to workspace (privileged)
        if: steps.guard.outputs.trusted == 'true'
        run: |
          # Security: Copy artifacts to workspace for deployment
          cp -r ./build-artifacts/frontend/dist ./frontend/
          cp -r ./build-artifacts/functions/lib ./functions/
          echo "✓ Verified artifacts copied to workspace"

      - name: Validate Firebase service account (privileged)
        if: steps.guard.outputs.trusted == 'true'
        env:
          # GitHub Actions secret - valid GitHub context variable
          # Configure in repository: Settings > Secrets and variables > Actions
          FIREBASE_SA: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_TARKOVTRACKER_ORG }}
        run: |
          if [ -z "$FIREBASE_SA" ]; then
            echo "ERROR: FIREBASE_SERVICE_ACCOUNT_TARKOVTRACKER_ORG secret is not set"
            exit 1
          fi
          # Validate JSON structure (redirect to /dev/null to avoid logging secrets)
          echo "$FIREBASE_SA" | python3 -m json.tool > /dev/null 2>&1 || {
            echo "ERROR: Firebase service account is not valid JSON"
            exit 1
          }
          echo "✓ Firebase service account is valid JSON"

      - name: Deploy to Firebase Hosting preview channel (privileged)
        if: steps.guard.outputs.trusted == 'true' # Context reference to guard step output
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: ${{ secrets.GITHUB_TOKEN }}
          # GitHub Actions secret - valid GitHub context variable
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_TARKOVTRACKER_ORG }}
          projectId: tarkovtracker-org
          channelId: pr${{ steps.validate_pr.outputs.PR_NUMBER }}
          expires: 7d

      - name: Clean up artifacts (privileged)
        if: always()
        run: |
          # Security: Always clean up artifacts
          rm -rf ./build-artifacts ./deployment-metadata
          echo "✓ Cleanup completed"
